Первое, что отмечу, Thread — это класс, Runnable — интерфейс, что весьма очевидное отличие =D

Также скажу, что Thread использует Runnable (композиция). То есть, у нас есть два пути:
Наследоваться от Thread, переопределить метод run, после чего создать данный объект и запустить поток через метод start().

Реализовать Runnable в определенном классе, реализовать его метод run(), после чего создать объект Thread, задав ему в конструктор этот объект-реализацию интерфейса Runnable. Ну и в конце запустить объект Thread с помощью метода start().

Что же предпочтительнее? Давайте немного поразмыслим:
при реализации интерфейса Runnable вы не изменяете поведение потока. По сути вы просто даете потоку что-то запустить. А это у нас композиция, что в свою очередь считается хорошим подходом.

реализация Runnable даёт больше гибкости вашему классу. Если вы наследуетесь от Thread, то действие, которое вы выполняете, всегда будет в потоке. Но если вы реализуете Runnable, это не обязательно будет просто поток. Ведь вы можете как запустить его в потоке, так и передать его какой-либо службе-исполнителю. Ну или просто передать его куда-то как задачу в однопоточном приложении.

использование Runnable позволяет логически отделить выполнение задачи от логики управления потоками.

в Java возможно только одиночное наследование, поэтому можно расширить только один класс. В то же время количество расширяемых интерфейсов неограниченно (ну не совсем неограниченное, а 65535, но вряд ли вы когда-то упретесь в этот лимит).

