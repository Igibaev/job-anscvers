Отказ от использования ORM может иметь как плюсы, так и минусы, и зависит от конкретного проекта и его требований.

Среди преимуществ отказа от ORM можно отметить:

Ускорение работы приложения - в случае использования ORM, часть времени работы приложения тратится на маппинг объектов на таблицы в базе данных. При отказе от ORM эту часть можно оптимизировать и ускорить.

Уменьшение издержек на сервер - использование ORM часто требует больших вычислительных ресурсов и объема памяти для маппинга объектов на таблицы в базе данных.

Упрощение кода - использование ORM может приводить к написанию более сложного и громоздкого кода, который труднее поддерживать и отлаживать.

Однако, использование ORM также имеет свои преимущества, включая:

Ускорение разработки - использование ORM может сократить время, затрачиваемое на разработку, поскольку ORM может автоматически генерировать SQL-запросы и код для работы с базой данных.

Упрощение разработки - ORM может значительно упростить код, который работает с базой данных, и уменьшить вероятность ошибок.

Поддерживаемость - использование ORM может облегчить поддержку приложения, поскольку ORM может автоматически генерировать код для обновления базы данных.

Таким образом, решение об использовании или отказе от ORM должно быть основано на конкретных требованиях и ограничениях проекта. Если проект требует высокой производительности и точного контроля над запросами к базе данных, то отказ от ORM может быть более эффективным решением. Однако, в случае больших и сложных проектов, использование ORM может значительно упростить и ускорить разработку.




Aday igibaev
разве отказ от ОРМ упрощает код? приведи пример если это правда
Отказ от ORM не всегда упрощает код, так как ORM может упростить работу с базой данных и уменьшить количество кода, связанного с работой с ней. Однако, иногда отказ от ORM может привести к упрощению кода, например, если речь идет о небольшом проекте с простой структурой данных и простыми операциями с базой данных.

Например, рассмотрим следующий пример кода на языке Java, который использует JDBC для выполнения запроса к базе данных и получения списка пользователей:

`public List<User> getUsers() {
List<User> users = new ArrayList<>();

    try (Connection connection = dataSource.getConnection()) {
        PreparedStatement statement = connection.prepareStatement("SELECT * FROM users");

        ResultSet resultSet = statement.executeQuery();

        while (resultSet.next()) {
            User user = new User();
            user.setId(resultSet.getLong("id"));
            user.setName(resultSet.getString("name"));
            user.setEmail(resultSet.getString("email"));
            users.add(user);
        }

        resultSet.close();
        statement.close();
    } catch (SQLException e) {
        throw new RuntimeException("Failed to get users", e);
    }

    return users;
}`
Как видно из примера, код для выполнения запроса к базе данных и получения списка пользователей достаточно громоздкий и сложный. В этом случае можно использовать ORM, чтобы упростить код и сократить количество операций, связанных с работой с базой данных.

Однако, если структура данных и операции с базой данных действительно просты, можно обойтись без ORM и написать более простой и понятный код. Например, следующий код выполняет ту же самую операцию, но без использования ORM:

`public List<User> getUsers() {
List<User> users = new ArrayList<>();

    try (Connection connection = dataSource.getConnection()) {
        Statement statement = connection.createStatement();

        ResultSet resultSet = statement.executeQuery("SELECT * FROM users");

        while (resultSet.next()) {
            User user = new User();
            user.setId(resultSet.getLong("id"));
            user.setName(resultSet.getString("name"));
            user.setEmail(resultSet.getString("email"));
            users.add(user);
        }

        resultSet.close();
        statement.close();
    } catch (SQLException e) {
        throw new RuntimeException("Failed to get users", e);
    }

    return users;
}`
Как видно из примера, код стал короче и проще, поскольку нет необходимости создавать отдельные объекты для выполнения запроса и получения результатов, как в случае с JDBC. Однако, при более сложной структуре данных и операциях с базой данных, использование ORM может быть более удобным и эффективным.




Aday igibaev
ну чето хиленько, я бы сказал что отказ от ОРМ не упрощает код, а наоборот усложняет его, так как отказ от ОРМ требует соблюдение транзакции, обязательный маппинг полей, постоянное создание коннекшенов в базу и следить чтобы все коннекшены закрывались
Вы правы, отказ от ORM может усложнить код в определенных случаях. Я хотел продемонстрировать, что в некоторых простых случаях отказ от ORM может упростить код, но в целом вы правы, что обычно использование ORM может значительно упростить работу с базой данных.

При отказе от ORM необходимо следить за многими аспектами, такими как управление транзакциями, маппинг полей, управление соединениями с базой данных, и это может быть сложно и трудоемко. Однако, в некоторых случаях, когда база данных проста и небольшая, а запросы к ней минимальны, отказ от ORM может быть оправданным.

Например, для простых CRUD-операций в приложении с использованием базы данных можно написать простой и легко поддерживаемый JDBC-код. Однако, при более сложных операциях, таких как запросы к базе данных, содержащие много таблиц, использование ORM может значительно упростить код и сделать его более понятным и легко поддерживаемым.