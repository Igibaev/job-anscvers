Первое, что нужно сказать — это то, что при полном выполнении метода run() поток автоматически уничтожается. Но иногда
нужно убить его досрочно, до завершения данного метода.

И что тогда делать? Возможно, у объекта Thread использовать метод stop()?

Как бы не так!

Данный метод считается устаревшим и может привести к сбоям системы. Ну а что тогда?

Есть два способа сделать это:

Первый — это использование своего внутреннего логического флага.

Давайте рассмотрим на примере.

У нас есть своя реализация потока, который должен выводить на экран некую фразу до его полной остановки:

```java

public class CustomThread extends Thread {
    private boolean isActive;

    public CustomThread() {
        this.isActive = true;
    }

    @Override
    public void run() {
        {
            while (isActive) {
                System.out.println("Поток выполняет некую логику...");
            }
            System.out.println("Поток остановлен!");
        }
    }

    public void stopRunningThread() {
        isActive = false;
    }
}
```

При использовании метода stopRunning() внутренний флаг становится false и метод run прекращает свою работу.

Давайте запустим его в main:

```java
System.out.println("Начало выполнения программы");
        CustomThread thread=new CustomThread();
        thread.start();
        Thread.sleep(3);
// пока наш основной поток спит, вспомогательный  CustomThread работает и выводит в коноль своё сообщение
        thread.stopRunningThread();
        System.out.println("Конец выполнения программы");
```

В итоге в консоли мы увидим что-то вроде этого:

Начало выполнения программы Поток выполняет некую логику... Поток выполняет некую логику... Поток выполняет некую
логику... Поток выполняет некую логику... Поток выполняет некую логику... Поток выполняет некую логику... Конец
выполнения программы Поток остановлен!

А это значит, что наш поток отработал, вывел некоторое количество сообщений в консоль и был успешно остановлен.

Отмечу, что количество выведенных сообщений от запуска к запуску будет разным, иногда дополнительный поток даже и не
выводил ничего.

Как я заметил, это зависит от времени сна основного потока, чем оно больше, тем меньше шанс что дополнительный поток
ничего не выведет. При времени сна 1мс вывода сообщений почти никогда не происходит, но если выставить 20мс, почти
всегда срабатывает.

Возможно, при малом времени поток просто не успевает запуститься и начать свою работу, а его сразу же останавливают.

Второй способ заключается в использовании на объекте Thread метода interrupted(), который возвращает значение
внутреннего флага прерывания (по умолчанию этот флаг false) и другого его метода interrupt() — ставящего этот флаг в
true (когда этот флаг true поток должен остановить свою работу).

Смотрим пример:

```java
public class CustomThread extends Thread {

    @Override
    public void run() {
        {
            while (!Thread.interrupted()) {
                System.out.println("Поток выполняет некую логику...");
            }
            System.out.println("Поток остановлен!");
        }
    }
}
```

Запуск в main:

```java
System.out.println("Начало выполнения программы");
        Thread thread=new CustomThread();
        thread.start();
        Thread.sleep(3);
        thread.interrupt();
        System.out.println("Конец выполнения программы");
```

Итог выполнения будет таким же, как и в первом случае, но данный подход мне нравится больше: мы пишем меньше кода и
больше используем уже готовый, стандатный функционал.