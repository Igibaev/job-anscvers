Для понимания ковариантности мы рассмотрим пример.

Предположим, у нас есть класс животного:

```java
public class Animal {
    void voice() {
        System.out.println("*тишина*");
    }
}

```

И некоторый расширяющий его класс Dog:

```java
public class Dog extends Animal {

    @Override
    public void voice() {
        System.out.println("Гав, гав, гав!!!");
    }
}

```

Как мы помним, родительскому типу мы можем без проблем присваивать объекты типа наследника:

```java
Animal animal=new Dog();
```

Это у нас будет ничто иное как полиморфизм. Удобно, гибко не так ли?

Ну а в случае со списком животных? Сможем ли мы задать списку с дженериком Animal список с объектами Dog?

List<Dog> dogs = new ArrayList<>(); List<Animal> animals = dogs;

В таком случае строка присвоения списку животных списка собак будет подчеркнута красным, т.е. компилятор не пропустит
данный код.

Несмотря на то, что вроде как это присваивание весьма логично (ведь переменной типа Animal мы можем присвоить объект
Dog) его сделать нельзя.

Это происходит потому, что если бы это было допустимо, в список, который изначально предназначен для Dog, мы сможем
положить объект Animal, при этом думая, что в списке у нас только Dogs.

И потом, к примеру, возьмём с помощью метода get() объект у того списка dogs, думая, что это собака, и вызовем у него
некоторый метод объекта Dog, которого нет у Animal. И как вы понимаете, это невозможно — упадет ошибка. Но, к счастью,
компилятор не пропускает данную логическую ошибку с присвоением списка потомков, списку родителей (и наоборот).

В Java возможно присвоение объектов списков лишь переменным списков с совпадающими дженериками. Это и называется
инвариацией.

Если бы могли это сделать, это называлось бы и называлось ковариацией.

То есть, ковариация — это если бы мы могли переменной типа List<Animal> задать объект типа ArrayList<Dog>.

Получается что в Java ковариантность не поддерживается? Как бы не так!

Но это делается своим, особым путем.

Для этого используется конструкция ? extends Animal. Она ставится дженериком переменной, которой мы хотим задать объект
списка, с дженериком потомка.

Эта конструкция дженерика значит, что подойдёт любой тип, который является потомком типа Animal (и тип Animal также
попадает под это обобщение).

В свою очередь, Animal может быть не только классом, но и интерфейсом (и пусть вас не вводит в заблуждение ключевое
слово extends).

Наше предыдущее присваивание мы можем выполнить следующим образом:

```java
List<Dog> dogs=new ArrayList<>();
        List<?extends Animal> animals=dogs;
```

В результате вы увидите в IDE, что компилятор не будет ругаться на данную конструкцию.

Давайте проверим работоспособность данной конструкции. Предположим, у нас есть метод, который заставляет всех переданных
ему животных издать звуки:

```java
public static void animalsVoice(List<?extends Animal> animals){
        for(Animal animal:animals){
        animal.voice();
        }
        }
```

Передадим ему список с собаками:

```java
List<Dog> dogs=new ArrayList<>();
        dogs.add(new Dog());
        dogs.add(new Dog());
        dogs.add(new Dog());
        animalsVoice(dogs);

```

В консоли мы увидим следующий вывод:

`Гав, гав, гав!!!
Гав, гав, гав!!!
Гав, гав, гав!!!`

А значит данный подход к ковариантности успешно работает.

Отмечу, что в список с данным дженериком ? extends Animal мы не можем вставить новые данные никакого типа: ни типа Dog,
ни даже типа Animal:

```java
List<Dog> dogs=new ArrayList<>();
        List<?extends Animal> animals=dogs;
        animals.add(new Dog());
        dogs.add(new Animal());
```

Собственно, в последних двух строках компилятор будет подчеркивать красным вставку объектов.

Это связано с тем, что мы не можем быть на сто процентов уверены, список с объектами какого типа будет присвоен списку с
данных дженериком <? extends Animal>.

Хотелось бы ещё рассказать про контравариантность, так как обычно это понятие идет всегда вместе с ковариантностью, и
как правило спрашивают о них вместе.

Это понятие — некоторая противоположность ковариантности, так как для данной конструкции используется тип наследника.

Предположим, нам нужен список, которому можно будет присвоить список с типом объектов, не являющихся предками объекта
Dog. При этом мы заранее не знаем, что это будут за конкретные типы.

В таком случае нас может выручить конструкция вида ? super Dog, для которой подходят все типы — прародители класса Dog:

```java
List<Animal> animals=new ArrayList<>();
        List<? super Dog>dogs=animals;
        dogs.add(new Dog());
        dogs.add(new Dog());
```

Мы можем смело добавлять в список с таким дженериком объекты типа Dog, ведь у него в любом случае присутствуют все
реализованные методы любого его прародителя.

Но мы не сможем добавить объект типа Animal, так как нет уверенности, что внутри будут именно объекты этого типа, а не,
например, Dog. Ведь мы можем запросить у элемента данного списка метод класса Dog, которого не будет в наличии у Animal.
В таком случае возникнет ошибка компиляции.

Также, если бы мы захотели реализовать предыдущий метод, но уже с данным дженериком:

```java
public static void animalsVoice(List<? super Dog>dogs){
        for(Dog dog:dogs){
        dog.voice();
        }
        }
```

мы бы получили ошибку компиляции в цикле for, так как мы не можем быть уверены, что пришедший список содержит объекты
типа Dog и свободно использовать его методы.

Если у данного списка мы вызовем метод dogs.get(0); — мы получим объект типа Object.

То есть для работы метода animalsVoice() нам как минимум нужно добавить небольшие манипуляции с сужением данных вида:

```java
public static void animalsVoice(List<? super Dog>dogs){
        for(Object obj:dogs){
            if(obj instanceof Dog){
                Dog dog=(Dog)obj;
                dog.voice();
            }
        }
    }   
```