Коллекции — одна из самых любимых тем на любом собеседовании Java-разработчика, и рассказывая об иерархии коллекций кандидаты часто говорят, что она начинается с интерфейса Collection. Но это не так, ведь над этим интерфейсом есть ещё один — Iterable.

Данный интерфейс представляет метод iterator(), который позволяет вызывать объект Iterator для текущей коллекции.

И что же такое этот объект Iterator?

Iterator — это объект предоставляющий возможность двигаться по коллекции и перебирать элементы, причем пользователю не нужно знать реализацию конкретной коллекции.

То есть, это некоторый указатель на элементы коллекции, который как бы смотрит на определенное место в ней.

У итератора есть такие методы:
hasNext() — возвращает true, если есть элемент, расположенный после указателя (данный метод позволяет узнать, достигнут ли конец коллекции);
next() — возвращает следующий элемент после указателя. Если такового не будет, выбрасывается NoSuchElementException. То есть перед использованием этого метода лучше убедиться в том, что элемент есть — с помощью hasNext();
remove() — удаляет из коллекции последний полученный элемент методом next(). Если же next() до вызова remove() ни разу не вызывали, будет брошено исключение — IllegalStateException;
forEachRemaining(<Consumer>) — выполняет переданное действие с каждым элементом коллекции (метод появился с Java 8).
Вот небольшой пример прохода по списку и удаления всех его элементов с помощью рассмотренных методов итератора:

```java

List<String> list = new ArrayList<>();
list.add("Hello ");
list.add("World, ");
list.add("It's ");
list.add("Amigo!");
Iterator iterator = list.iterator();

while(iterator.hasNext()) {
iterator.next();
iterator.remove();
}
System.out.println(list.size());

```

В консоли будет выведено:

0

А это значит, что удаление элементов прошло успешно. Получив итератор, можно было бы воспользоваться методом для вывода всех элементов на экран:

iterator.forEachRemaining(x -> System.out.print(x));

Но после этого итератор стал бы непригоден для дальнейшего использования, так как он обошел бы весь список, а методов для обратного перебора у обычного итератора нет.

Тут мы плавно подходим к LinkedList, а именно — к его методу listIterator(), который возвращает модернизированный вид итератора — ListIterator.

Помимо методов обычного (стандартного) итератора, у этого есть дополнительные:
add(<Element>) — вставляет новый элемент в список;
hasPrevious() — возвращает true, если есть элемент, расположенный перед указателем (есть ли предыдущий элемент);
nextIndex() — возвращает индекс в списке следующего элемента после указателя;
previous() — возвращает предыдущий элемент (до указателя);
previousIndex() — возвращает индекс предыдущего элемента;
set(<Element>) — заменяет последний элемент, возвращенный методами next() или previous().
Как видим, функционал этого итератора гораздо интереснее: он позволяет ходить в обе стороны и развязывает руки в работе с элементами.

Также когда говорят об итераторах иногда подразумевают сам паттерн. Чтобы не попасть впросак и рассказать о нем убедительно, читайте эту статью о паттерне Iterator.