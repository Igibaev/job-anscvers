Между потоками можно обмениваться данными, используя различные механизмы синхронизации. Один из самых простых и
распространенных способов - это использование общей переменной, доступ к которой осуществляется с помощью механизмов
синхронизации.

Есть несколько способов синхронизации между потоками:

Синхронизированные методы и блоки - это механизм, который позволяет синхронизировать доступ к методу или блоку кода,
чтобы только один поток мог исполнять их в данный момент времени.

Методы wait() и notify() - это механизмы, позволяющие потокам сообщать друг другу о том, что они готовы к выполнению или
находятся в ожидании. Метод wait() приостанавливает выполнение потока и освобождает монитор, а метод notify()
возобновляет выполнение потока, который находится в состоянии ожидания.

Метод join() - это механизм, который позволяет потоку ожидать завершения выполнения другого потока. Поток, вызывающий
метод join(), приостанавливается до тех пор, пока поток, для которого он вызывается, не завершится.

Кроме того, существуют другие механизмы для обмена данными между потоками, такие как блокирующие очереди и семафоры.

Для обмена данными между потоками можно использовать много разных подходов и средств: например, воспользоваться
атомарными переменными, синхронизированными коллекциями, семафором. Но для решения данной задачи я приведу пример с
Exchanger.

Exchanger — это класс синхронизации из concurrent пакета, который облегчает обмен элементами между парой потоков за счет
создания общей точки синхронизации. Его использование упрощает обмен данными между двумя потоками.

Механизм его работы весьма прост: он ждет, пока два отдельных потока не вызовут его метод exchange().

Между ними создаётся что-то вроде точки обмена: первый поток кладет свой объект и получает взамен объект другого, а тот
в свою очередь получает объект первого и кладет свой.

То есть, первый поток использует метод exchange() и бездействует до тех пор, пока другой поток не вызовет метод
exchange() у этого же объекта и между ними не произойдёт обмен данными.

В качестве примера рассмотрим следующую реализацию класса Thread:

```java

public class CustomThread extends Thread {
    private String threadName;
    private String message;
    private Exchanger<String> exchanger;

    public CustomThread(String threadName, Exchanger<String> exchanger) {
        this.threadName = threadName;
        this.exchanger = exchanger;
    }

    public void setMessage(final String message) {
        this.message = message;
    }

    @Override
    public void run() {
        while (true) {
            try {
                message = exchanger.exchange(message);
                System.out.println(threadName + " поток получил сообщение: " + message);
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

В конструкторе потока мы задаём объект Exchanger, принимающий объекты типа String, а в запуске (в методе run) используем
его exchange() для обмена сообщением с другим потоком, использующим данный метод в этом же Exchanger.

Давайте запустим его в main:

```java
Exchanger<String> exchanger=new Exchanger<>();
        CustomThread first=new CustomThread("Первый ",exchanger);
        first.setMessage("Сообщение первого потока");
        CustomThread second=new CustomThread("Второй",exchanger);
        second.setMessage("Сообщение второго потока");
        first.start();
        second.start();

```

В консоли будет выведено:

`
Первый поток получил сообщение: Сообщение второго потока Второй поток получил сообщение: Сообщение первого потока Второй поток получил сообщение: Сообщение второго потока Первый поток получил сообщение: Сообщение первого потока Второй поток получил сообщение: Сообщение первого потока Первый поток получил сообщение: Сообщение второго потока ...
`

Это значит, что обмен данными между потоками проходит успешно.