ООП (объектно-ориентированное программирование) - это парадигма программирования, основанная на концепции объектов, которые взаимодействуют друг с другом для выполнения задач.

Основными принципами ООП являются:

Наследование - возможность создавать новый класс на основе уже существующего класса, наследуя его свойства и методы. Пример: класс Cat может наследоваться от класса Animal, чтобы наследовать его свойства и методы, связанные с животными.

Инкапсуляция - механизм сокрытия данных внутри объекта, чтобы избежать непосредственного доступа извне. Пример: создание полей класса, которые имеют модификатор доступа private, чтобы они были доступны только внутри класса.

Полиморфизм - возможность использовать один и тот же метод для разных типов данных. Пример: создание метода eat(), который может быть вызван для объектов разных классов, таких как Cat и Dog, потому что они оба могут есть.

Абстракция - создание абстрактного класса или интерфейса, который описывает общие свойства и методы, не предоставляя конкретную реализацию. Пример: создание интерфейса Animal, который описывает методы, связанные с животными, но не предоставляет реализации.

Применение этих принципов помогает создавать более чистый, гибкий и расширяемый код в рамках ООП.

Абстрактный класс и интерфейс - это два основных механизма для организации абстракции в объектно-ориентированном программировании. Оба они используются для создания типов данных, которые определяют некоторый контракт для классов, реализующих эти типы. Но у них есть ряд различий.

Абстрактный класс - это класс, который не может быть создан напрямую, только через наследование от него. Абстрактный класс может иметь как реализацию методов, так и абстрактные методы, которые должны быть переопределены в подклассах. Он может содержать как общую функциональность, так и абстрактные методы, которые должны быть реализованы в подклассах.

Интерфейс - это тип данных, который определяет только контракт, но не содержит реализации. Интерфейс может содержать только абстрактные методы, статические методы и константы. Класс, который реализует интерфейс, должен реализовать все его методы. Интерфейсы позволяют создавать множественное наследование в Java.

Примеры использования абстрактных классов:

```java
public abstract class Shape {
private String color;
public Shape(String color) {
this.color = color;
}
public abstract double getArea();
}

public class Circle extends Shape {
private double radius;
public Circle(String color, double radius) {
super(color);
this.radius = radius;
}
public double getArea() {
return Math.PI * radius * radius;
}
}
```
Примеры использования интерфейсов:

```java
public interface Drawable {
void draw();
}

public class Circle implements Drawable {
private double radius;
public Circle(double radius) {
this.radius = radius;
}
public void draw() {
// нарисовать круг
}
}

public interface Moveable {
void move();
}

public class Car implements Moveable, Drawable {
private String model;
private int x, y;
public Car(String model, int x, int y) {
this.model = model;
this.x = x;
this.y = y;
}
public void move() {
// переместить машину
}
public void draw() {
// нарисовать машину
}
}
```
Таким образом, использование абстрактных классов и интерфейсов зависит от того, что вы хотите достичь. Если вы хотите определить базовый функционал и имеете общую реализацию, используйте абстрактный класс. Если вы хотите только определить контракт, используйте интерфейс.

Полиморфизм - это возможность объектов с одинаковой спецификацией иметь различную реализацию. Это означает, что объекты могут реагировать на один и тот же метод, который определен в общем интерфейсе или классе, по-разному.

Рассмотрим пример полиморфизма на языке Java. Предположим, у нас есть интерфейс Shape, который определяет метод для вычисления площади фигуры:

```java
public interface Shape {
double getArea();
}
```
Теперь мы можем создать несколько классов, реализующих этот интерфейс, например, классы Circle и Square:

```java
public class Circle implements Shape {
private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Square implements Shape {
private double side;

    public Square(double side) {
        this.side = side;
    }
    
    @Override
    public double getArea() {
        return side * side;
    }
}
```
Теперь мы можем создать массив фигур различных типов и вызвать у каждой фигуры метод getArea():

```java
Shape[] shapes = new Shape[2];
shapes[0] = new Circle(2);
shapes[1] = new Square(3);

for (Shape shape : shapes) {
System.out.println(shape.getArea());
}
```

Здесь мы создаем массив shapes типа Shape и добавляем в него экземпляры классов Circle и Square. Затем мы перебираем каждую фигуру в массиве и вызываем ее метод getArea(). Таким образом, каждый объект реализует метод getArea() по-своему, и мы получаем площадь каждой фигуры в зависимости от ее типа. Это и есть пример полиморфизма.