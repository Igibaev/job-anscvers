Основные/базовые средства для использования многопоточности в Java:
Synchronized — механизм закрытия (блокирования) метода / блока при вхождении в него потока, от других потоков. Volatile
— механизм обеспечения согласованного доступа к переменной разными потокам, то есть с наличием данного модификатора у
переменной все операции присвоения и чтения ее должны быть атомарными. Другими словами потоки не будут копировать эту
переменную в свою локальную память и изменять ее, а будут изменять ее изначальное значение. Подробнее про volatile
читайте вот тут. Runnable — интерфейс, реализовав который (в частности его метод run) в некотором классе:

```java
public class CustomRunnable implements Runnable {
    @Override
    public void run() {
// некоторая логика
    }
}
```

И создав объект этого класса, можно запустить новый поток, задав этот объект в конструктор нового объекта Thread, и
вызвав у него метод start():

Runnable runnable = new CustomRunnable(); new Thread(runnable).start();

Метод start запускает реализованный метод run() в отдельном потоке. Thread — класс, наследовав от которого (при этом
переопределив метод run):

```java
public class CustomThread extends Thread {
    @Override
    public void run() {
// некоторая логика
    }
}
```

И создав объект данного класса и запустив его с помощью метода start(), запустим тем самым новый поток:

`new CustomThread().start();`
Concurrency — пакет с инструментами для работы в многопоточной среде. Он состоит из:
Concurrent Collections — набор коллекций, специализированных под работу в многопоточной среде. Queues —
специализированные очереди для многопоточной среды (блокирующие и неблокирующие). Synchronisers — специализированные
утилиты для работы в многопоточной среде. Executors — механизмы для создания пулов потоков. Locks — механизмы
синхронизации потоков (более гибкие нежели стандартные — synchronized, wait, notify, notifyAll). Atomics — классы
оптимизированные под многопоточное выполнение, именно у них каждая операция — атомарная.